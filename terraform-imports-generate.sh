#!/bin/bash

# Usage: terraform-generate-imports <state-file> <output-file>
# error out if the number of arguments is not 2
if [ $# -ne 2 ]; then
  echo "Usage: $0 <state-file> <output-file>"
  exit 1
fi

# File containing the list of Terraform state entries
STATE_FILE=$1

# Output file where the results will be saved
OUTPUT_FILE=$2

function found_terraform_resource_id() {
  entry=$1
  STATE_FILE=$2
  # Use terraform state show to get the details of the entry
  if [[ $entry == *.aws_iam_role_policy_attachment.* ]]; then
    # Based on https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_role_policy_attachment#import
    # handle aws_iam_role_policy_attachment resources differently
    # Extract role for aws_iam_role_policy_attachment resources
    role=$(terraform state show -state=$STATE_FILE $entry | awk '/^ *role[[:space:]]*=[[:space:]]*"/ {print $3; exit}')
    # Extract policy_arn for aws_iam_role_policy_attachment resources
    policy_arn=$(terraform state show -state=$STATE_FILE $entry | awk '/^ *policy_arn[[:space:]]*=[[:space:]]*"/ {print $3; exit}')
    attribute="$role/$policy_arn"
  else
    # Default to extracting id for all other resource types
    attribute=$(terraform state show -state=$STATE_FILE $entry | awk '/^ *id[[:space:]]*=[[:space:]]*"/ {print $3; exit}')
  fi
}

# Ensure the output file is empty
echo "# This file is automatically generated by https://github.com/amazingandyyy/terraform-utils" > "$OUTPUT_FILE"
echo "# It contains import statements for each resource in the source's state file $STATE_FILE" >> "$OUTPUT_FILE"
echo "# 1. Depends on the destination's terraform structure, you MIGHT need to modify the target for \`to\` for each block" >> "$OUTPUT_FILE"
echo "# 2. Some resource ids might NOT be correctly extracted, please verify the generated import statements" >> "$OUTPUT_FILE"
echo "# NOTE: Please verify the generated import statements before running them" >> "$OUTPUT_FILE"
echo "# NOTE: This script is extremely experimental and under active development, use it at your own risk." >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

LIST=$(terraform state list -state="$STATE_FILE")
total_found=$(echo "$LIST" | wc -l | xargs) # Total items found in the state file

# Initialize counters
total_items=0
skipped_items=0
id_found_items=0

echo "Start processing $total_found items found in the state file $STATE_FILE..."

# Reset skipped_items for accurate counting during the main loop
skipped_items=0

# Read each line from the output of `terraform state list`
echo "$LIST" | while IFS= read -r entry; do
  let total_items+=1
  
  # Check if the entry starts with module.metadata or contains .data.
  if [[ $entry == data.* ]] || [[ $entry == *".data."* ]]; then
    let skipped_items+=1
    echo "$total_items Skipping data block: $entry"
    echo "# $entry" >> "$OUTPUT_FILE"
    echo "# skip importing data blocks" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    continue
  fi
  
  # Skip entries that start with "module.metadata." and note the skip
  if [[ $entry == module.metadata.* ]]; then
    let skipped_items+=1
    echo "$total_items Skipping metadata module: $entry"
    echo "# $entry" >> "$OUTPUT_FILE"
    echo "# skip importing metadata modules" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    continue
  fi
  
  attribute=$(found_terraform_resource_id $entry $STATE_FILE)

  if [[ -z $attribute || $attribute == "null" ]]; then
    attribute="\"not found\""
  else
    let id_found_items+=1
  fi
  
  echo "$total_items Resource attribute of $entry is $attribute"
  
  echo "# import for $entry" >> "$OUTPUT_FILE"
  echo "import {" >> "$OUTPUT_FILE"
  echo "  to = $entry" >> "$OUTPUT_FILE"
  echo "  id = $attribute" >> "$OUTPUT_FILE"
  echo "}" >> "$OUTPUT_FILE"
  echo "" >> "$OUTPUT_FILE"
  
done

# Print summary information
echo "Summary:"
echo "Total items processed: $total_items"
echo "Skipped items: $skipped_items"
echo "Items with attribute found: $id_found_items"
echo "Results saved to $OUTPUT_FILE"
